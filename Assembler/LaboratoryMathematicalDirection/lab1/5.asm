.486
.MODEL Flat, StdCall ; StdCall - мантра
include \masm32\include\msvcrt.inc
includelib \masm32\lib\msvcrt.lib

.data
Format db ' %d', 0
; Это значит x1 - с типом dw (2 байта) = 0
x1 dw 0
y1 dw 0
x2 dw -3
y2 dw 2
AREA dd ?
.CODE
;В четырёх знаковых 2-байтных переменных x1, y1, x2, y2 заданы координаты двух
; противоположных вершин прямоугольника (не обязательно левой нижней и верхней
; правой!). Запишите в знаковую 4-байтную переменную площадь этого прямоугольника (не нужно обязательно делать это значение положительным!). Если задача решается
; позже, не нужно использовать инструкции сравнения чисел и условных переходов.
main:
	; Прикол, в регистрах ассемблера всегда лежит мусор
	; например во время запуска программы в eax может лежать 0x2f3edd11
	; поэтому когда мы ложим в ax 0 мы получаем в eax 0x2f3e0000
	; нам же нужно 0x00000000
	; поэтому регистр нужно занулить это можно сделать 2 способами
	; mov eax, 0 - это нормально
	; xor eax, eax - ксор сам с собой тоже даст ноль, это абсолютно асемблерская практика, она быстрее чем mov eax, 0
	xor eax, eax
	xor ebx, ebx	
	mov ax, x1
	mov bx, x2

	; Вызов процедуры absolut
	call absolut
	
	; Положить содержимое eax в стек
	push eax

	xor eax, eax
	xor ebx, ebx	
	mov ax, y1
	mov bx, y2
		
	; Вызов процедуры absolut
	call absolut
		
	; Вытащить верхушку стека в регистр ecx
	pop ecx

	mul ecx
		
	mov AREA, eax
	mov edx, AREA
		
	; Вывод результата на экран
	invoke crt_printf, addr Format, edx
	
	; И это мантра (пока что)
	ret
	
absolut:
	sub ax, bx

	; Выносит знак ax в dx (если ax отрицательное то в dx 0xffff)
	cwd
	
	; Финты ущами с битиками для получения положительного числа
	xor ax, dx
	sub ax, dx
	; Команда возврата из процедуры
	ret
	
end main
